# C++ Signal Handling

Signal handling in C++ allows us to respond to various events and interrupts that occur during program execution. Signals can be generated by the operating system or other processes. Let's explore how signal handling works in C++.

## Registering Signal Handlers

To handle signals in C++, we need to register signal handlers using the `signal()` function from the `<csignal>` header. Here's an example that registers a signal handler for the `SIGINT` signal, which is generated when the user presses `Ctrl+C`:

```cpp
#include <iostream>
#include <csignal>

void signalHandler(int signal) {
    std::cout << "Received signal: " << signal << std::endl;
}

int main() {
    std::signal(SIGINT, signalHandler); // Register the signal handler

    std::cout << "Press Ctrl+C to generate a signal..." << std::endl;
    while (true) {
        // Perform program logic
    }

    return 0;
}
```

In this example, we define a signal handler function `signalHandler()` that takes the signal number as an argument. We then use `std::signal(SIGINT, signalHandler)` to register the signal handler for the `SIGINT` signal. When the user presses `Ctrl+C`, the signal handler function will be called.

## Signal Handling Behavior

When a signal is received, the normal flow of execution is interrupted, and the registered signal handler is called. However, the behavior of signal handling can vary depending on the signal and the platform. Some signals may terminate the program by default, while others can be caught and handled.

To customize the behavior of a signal handler, we can use the `sigaction()` function instead of `signal()`. It provides more control over signal handling, including the ability to block signals during signal handling and specify additional flags.

## Handling Specific Signals

Different signals serve different purposes and can be used to handle specific events. Here are some commonly used signals:

- `SIGINT` (Interrupt): Generated by the user pressing `Ctrl+C` to interrupt the program.
- `SIGTERM` (Termination): Sent by the system to request termination of the program.
- `SIGSEGV` (Segmentation Violation): Indicates an invalid memory access, such as dereferencing a null pointer.
- `SIGILL` (Illegal Instruction): Indicates the execution of an illegal or unknown instruction.
- `SIGUSR1` and `SIGUSR2` (User-defined): Can be used for custom purposes.

It's important to note that not all signals can be caught and handled. Some signals, such as `SIGKILL` and `SIGSTOP`, cannot be caught or ignored.

## Signal Safety

Signal handlers should be designed to be signal-safe, as they can be called asynchronously at any point during program execution. Signal-safe functions are those that are reentrant and do not use non-atomic global variables or perform unsafe operations.

In general, signal handlers should avoid complex operations and focus on quickly and safely performing minimal tasks, such as setting flags or modifying shared variables protected by synchronization mechanisms.

## Conclusion

Signal handling in C++ allows us to respond to various signals and interrupts during program execution. By registering signal handlers, we can customize the behavior of our programs and handle specific events. It's important to understand the signals available, their default behaviors, and the limitations of signal handling in order to write robust and reliable signal handling code.
